# 9 Programação Orientada a Objetos: Herança

- 9.1 [Introdução](#91-introdução)
- 9.2 [Classes Base e classes Derivadas](#92-classes-base-e-classes-derivadas)
- 9.3 [Membros protected e internal](#93-membros-protected-e-internal)
- 9.4 [Relacionamento entre Classes Base e Classes Derivadas](#94-relacionamento-entre-classes-base-e-classes-derivadas)
- 9.5
- 9.6
- 9.7

## 9.1 Introdução

A herança é uma forma de reutilização de software em que as classes são criadas
pela absorção dos dados e comportamentos de uma classe já existente e aprimorando-as com novos recursos.

Ao criar uma classe, em vez de escrever variáveis de instância e métodos completamente novos,
o programador pode indicar que a nova classe deve herdar as variáveis de classe, propriedades e métodos de outra classe.
A classe anteriormente definida é chamada de **classe base**, e a nova classe é referida como **classe derivada**.
Uma vez criada, cada classe derivada pode se tornar a classe base de futuras classes derivadas.

Ao contrário do C++, o **C# não** suporta **herança múltipla**.

Fazemos uma distinção entre o **relacionamento** "É um" e o **relacionamento** "Tem um".\
"**É um**" representa a herança.\
"**Tem um**" significa composição.

Uma classe derivada pode acessar os membros não b de sua classe base.

(*Pode ser útil pesquisar mais sobre*)

## 9.2 Classes Base e classes Derivadas

Frequentemente, um objeto de uma classe "é um" objeto de outra classe também. Por exemplo, um retângulo **é um** quadrilátero.
Assim, pode-se dizer que a classe **Retangulo** **herda** da classe **Quadrilatero**.
Nesse contexto, a classe **Quadrilatero** é uma classe base, e a classe **Retangulo** é uma classe derivada.

Os relacionamentos de herança formam estruturas hierárquicas do tipo árvore.
Uma classe existe em um relacionamentos hierárquico com suas classes derivadas.
Embora as classes possam existir independentemente, quando elas são empregadas em organização de herança se tornam afiliadas de outras classes.

(*Pode ser útil pesquisar mais sobre*)

## 9.3 Membros protected e internal

Os membros **internal** de uma classe base podem ser acessados apenas nessa classe base ou em todas as classes derivadas dessa classe base.

Os membros **internal** de uma classe base podem ser acessados apenas pelos objetos declarados no mesmo assembly.

## 9.4 Relacionamento entre Classes Base e Classes Derivadas

Nesta seção usamos uma hierarquia de ponto e círculo para discutir o relacionamento entre uma classe base e uma classe derivada.
Dividimos nossa discussão do relacionamento de ponto e círculo em várias partes.

- Fig. 9.4: [Point.cs](./Fig-9.04%20-%20Point.cs)\
A classe Point representa um par de coordenadas x, y.

Note que o método **ToString** contém a palavra-chave **override** (sobrepor) em sua declaração.
Toda a classe em C# herda direta ou indiretamente da classe **System.Object**, que é a raiz da hierarquia de classes.

Em C#, um método da classe base deve ser declarado como **virtual**, caso esse método deva ser sobreposto em uma classe derivada.

- Fig. 9.5: [PointTest.cs](./Fig-9.05%20-%20PointTest.cs)\
Testando a classe Point.

- Fig. 9.6: [Circle.cs](./Fig-9.06%20-%20Circle.cs)\
A classe Circle contém um par de coordenadas x, y e um raio.

Parece que copiamos o código da classe **Point** literalmente, o colocamos no código da classe **Circle** e depois modificamos a classe **Circle** para incluir um raio.

- Fig. 9.7: [CircleTest.cs](./Fig-9.07%20-%20CircleTest.cs)\
Testando a classe Circle.

Como uma classe derivada, **Circle2** herda todos os membros da classe **Point**, exceto os construtores.

- Fig. 9.8: [Circle2.cs](./Fig-9.08%20-%20Circle2.cs)\
A classe CIrcle2 que herda da classe Point.

**Circle2** não pode acessar os membros **private** da classe base **Point**, **x** e **y**.
O C# impõe rigorosamente a restrição sobre o acesso a membros de dados **private**,
de modo que mesmo uma classe derivada não possa acessar dados **private** da classe base.

- Fig. 9.9: [Point2.cs](./Fig-9.09%20-%20Point2.cs)\
A classe Point2 contém um par de coordenadas x, y como dados protegidos.

A classe **Circle3** modifica a classe **Circle2** para herda da classe Point2, em vez de herdar da classe **Point**.
Como  a classe **Circle3** é uma classe derivada da classe **Point2**,
ela pode acessar diretamente as variáveis-membro **protected** da classe **Point2**, **x**, e **y**, e o compilador não gera erros ao compilar.

- Fig. 9.10: [Circle3.cs](./Fig-9.10%20-%20Circle3.cs)\
A classe Circle3 que herda da classe Point2.

- Fig. 9.11: [CircleTest3.cs](./Fig-9.11%20-%20CircleTest3.cs)\
Testando a classe Circle3.

No exemplo anterior declaramos as variáveis de instância da classe base como **protected**,
para que uma classe derivada pudesse modificar seus valores diretamente.

O uso de variáveis **protected** possibilita um ligeiro aumento no desempenho, pois evitamos a ocorrência de carga adicional de uma chamada de método para o acessor **set** ou **get** de uma propriedades

Entretanto, na maioria dos aplicativos C#, em que a interação com o usuário compreende uma grande parte do tempo de execução, a otimização oferecida pelo uso de variáveis **protected** é desprezível.

O uso de variáveis de instância **protected** cria dois grandes problemas.\
Primeiro, o objeto da classe derivada não precisa usar uma propriedade para configurar o valor dos dados **protected** da classe base.
Portanto, um objeto da classe derivada pode facilmente atribuir um valor inválido para os dados **protected**, deixando assim o objeto em um estado inconsistente.

O segundo problema do uso de dados **protected** é que os métodos da classe derivada são mais provavelmente escritos para depender da implementação da classe base.
Na prática, as classes derivadas devem depender apenas dos serviços da classe base, e não da implementação da classe base.
